#!/bin/bash

set -uo pipefail

if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
   >&2 echo "FATAL: run this script, don't source it."
   return 1 2>/dev/null || exit 1
fi

rootpath() {
   local dir=$(dirname "$(readlink -e "${BASH_SOURCE[0]}")")
   if [[ -f "${dir}/LICENSE" ]] ; then
      echo "$dir"
   elif [[ -d /usr/share/rpi-image-gen ]] ; then
      echo /usr/share/rpi-image-gen
   else
      >&2 echo "FATAL: cannot locate project root" ; exit 1
   fi
}
readonly IGTOP=$(rootpath)

# Load helpers
source "$IGTOP/lib/cli.sh"
source "$IGTOP/lib/common.sh"
source "$IGTOP/lib/dependencies.sh"
source "$IGTOP/lib/tools.sh"


# cli
cmd=${1:-}
shift
case $cmd in
   build|clean|layer|metadata|config) ;;
   help) cli_help ; exit 0 ;;
   *) cli_help; die "Unknown command" ;;
esac
argv=("$@")

if [[ ${argv[0]:-} == -h || ${argv[0]:-} == --help ]]; then
  case $cmd in
    layer|metadata|config) exec "$IGTOP/bin/ig" "$cmd" --help ;;
    build|clean) cli_help_"$cmd"; exit 0 ;;
  esac
fi


# Host context init
dependencies_check --category bootstrap "${IGTOP}/depends" || exit 1
TMPDIR=$(mktemp -d || exit 1 )
trap 'rm -rf "$TMPDIR"' EXIT
$IGTOP/bin/ig env "${argv[@]}" > "${TMPDIR}/host.json" || die
source <("${IGTOP}/scripts/host2sh.py" "${TMPDIR}/host.json")

: "${HOST_CONFIG_PATH?missing}"
: "${HOST_LAYER_PATH?missing}"
: "${HOST_EXEC_PATH?missing}"
: "${INTERACTIVE?missing}"
: "${ONLY_FS?missing}"
: "${ONLY_IMAGE?missing}"

# For dynamic layers
DYNROOT="${TMPDIR}/dynamic"
mkdir -p "${DYNROOT}/layer"
HOST_LAYER_PATH="DYNlayer=${DYNROOT}/layer:${HOST_LAYER_PATH}"

PATH="$HOST_EXEC_PATH:$PATH"
export PATH

# shortcut to loaders
case $cmd in
   build|clean)
      [[ -z ${HOST_CONFIG_FILE:-} ]] && { cli_help_"$cmd" ; die ;}
      ;;
   layer)
      exec "$IGTOP/bin/ig" layer --path "$HOST_LAYER_PATH" "${argv[@]}"
      ;;
   metadata|config)
    exec "$IGTOP/bin/ig" "$cmd" "${argv[@]}"
    ;;
esac


# cmdline
OVRF="${TMPDIR}/overrides"
: > "$OVRF"
[[ ${#OVERRIDES[@]} -gt 0 ]] && printf '%s\n' "${OVERRIDES[@]}" >> "$OVRF"
[[ -n ${HOST_BUILD_DIR:-} ]] && printf 'IGconf_sys_workroot="%s"\n' "$HOST_BUILD_DIR" >> "$OVRF"
# Must hold sane key=value pairs
while IFS= read -r line || [ -n "$line" ]; do
   case "$line" in
      [A-Za-z_][A-Za-z0-9_]*=*) ;;
      *)
         nl -ba "$OVRF" >&2
         die "Overrides must be provided as key=value pairs."
         ;;
    esac
done < "$OVRF"


# Ready for pipeline flow
dependencies_check --category all "${IGTOP}/depends" || exit 1
declare -A ctx=()
ctx[INTERACTIVE]="${INTERACTIVE:?missing}"
ctx[ONLY_FS]="${ONLY_FS:?missing}"
ctx[ONLY_IMAGE]="${ONLY_IMAGE:?missing}"
ctx[SRCROOT]="${SRCROOT:-$(realpath -e .)}"


###############################################################################
# Stage 1: Parameter assembly
#   Parse config
#   Seed env for subsequent stages
###############################################################################
parameter_assembly()
{
   msg "\nPARAM"

   # Toolchain variables. Native unless ARCH forces cross.
   DEB_BUILD_ARCH_VAL="${DEB_BUILD_ARCH:-$(dpkg-architecture -qDEB_BUILD_ARCH)}"
   DEB_BUILD_GNU_TYPE_VAL="${DEB_BUILD_GNU_TYPE:-$(dpkg-architecture -a"$DEB_BUILD_ARCH_VAL" -qDEB_BUILD_GNU_TYPE)}"

   if [ -n "${ARCH:-}" ]; then
      DEB_HOST_ARCH_VAL=${DEB_HOST_ARCH:-$(dpkg-architecture -a"$ARCH" -qDEB_HOST_ARCH)}
   else
      DEB_HOST_ARCH_VAL=${DEB_HOST_ARCH:-$DEB_BUILD_ARCH_VAL}
   fi
   DEB_HOST_GNU_TYPE_VAL="${DEB_HOST_GNU_TYPE:-$(dpkg-architecture -a"$DEB_HOST_ARCH_VAL" -qDEB_HOST_GNU_TYPE)}"

   TOOLCHAIN_MODE=$([ "$DEB_BUILD_ARCH_VAL" = "$DEB_HOST_ARCH_VAL" ] && echo native || echo cross)

   # Read config, writing all settings to file. Deferred variable resolution in pipeline
   # means that variable expansion does not happen here, so a config file can use any
   # variable it wants (from layers, env, anchors etc). Nothing is resolved until pipeline runs.
   env \
      ig config \
      --path "$HOST_CONFIG_PATH" \
      "$HOST_CONFIG_FILE"     \
      --overrides "$OVRF" \
      --write-to "${TMPDIR}/config.env" \
      || die "Config parse failed"

   # These canonical variables are always provided to pipeline
   cat >> "${TMPDIR}/config.env" <<EOF
DEB_BUILD_ARCH="$DEB_BUILD_ARCH_VAL"
DEB_BUILD_GNU_TYPE="$DEB_BUILD_GNU_TYPE_VAL"
DEB_HOST_ARCH="$DEB_HOST_ARCH_VAL"
DEB_HOST_GNU_TYPE="$DEB_HOST_GNU_TYPE_VAL"
TOOLCHAIN_MODE="$TOOLCHAIN_MODE"
IGTOP="$IGTOP"
LAYER_HOOKS="${IGTOP}/layer-hooks"
RPI_TEMPLATES="${IGTOP}/templates/rpi"
DYNROOT="$DYNROOT"
EOF

   # Conditional
   [[ -n "${SRCROOT:-}" ]] && \
      printf 'SRCROOT="%s"\n' "$SRCROOT" >> "${TMPDIR}/config.env"

  msg "\nENV" 
  cat ${TMPDIR}/config.env
}


###############################################################################
# Stage 2: Layer processing
#   Collect all specified layers
#   Ingest config environment and run pipeline to output the build config
#   Expand all variables and generate layer order
#   Write bootstrap information to file
##############################################################################
collect_layers()
{
   msg "\nLAYER"

   local -a layers=(essential)
   _collect() {
      local k=$1 v=$2
      case $k in
         IGconf_device_layer|IGconf_image_layer|IGconf_layer_*) layers+=("$v");;
      esac
   }
   mapfile_kv "${TMPDIR}/config.env" _collect

   msg "PIPELINE: ${layers[*]}"
   msg "SEARCH: $HOST_LAYER_PATH"

   # Generate the bootstrap information, resolving all variables. Configuration
   # input is only from the input env file, so run it in a clean room.
   env -i PATH=$PATH \
     ig pipeline \
      --env-in "${TMPDIR}/config.env" \
      --layers "${layers[@]}" \
      --path "$HOST_LAYER_PATH" \
      --env-out "${TMPDIR}/env.out" \
      --order-out "${TMPDIR}/layer.order" \
      || die "pipeline failed"

   msg "PIPELINE: OK"

   # Normalise
   safe_kv "${TMPDIR}/env.out" > "${TMPDIR}/env.safe"

   # Expand all variables with a strict policy, posix only
   local -a vars
   mapfile -t vars < <(grep -oE '^[A-Za-z_][A-Za-z0-9_]*' "${TMPDIR}/env.safe")

   if ! env -i POSIXLY_CORRECT=1 \
      /bin/sh -c '
         set -aeu
         . "$1"
         shift
         for v in "$@"; do
            eval "val=\${$v-}"
            printf "%s=\"%s\"\n" "$v" "$val"
         done
         ' _ "${TMPDIR}/env.safe" "${vars[@]}" > "${TMPDIR}/final.env"
      then
         nl -ba "${TMPDIR}/env.safe" >&2
         die "Layer env expansion failed"
   fi

   # Write bootstrap information
   local bdir=$(get_var IGconf_sys_bootstrapdir "${TMPDIR}/final.env") || \
      die "No bootstrap dir"

   mkdir -p "$bdir" || die
   for f in final.env layer.order host.json ; do
      src="${TMPDIR}/$f"
      [[ -f "$src" ]] || die "Missing bootstrap file: $src"
      cp "$src" "$bdir" || die
   done
   if [ -d "${DYNROOT}" ] ; then
      mkdir -p "${bdir}/dynamic" && rsync -a ${DYNROOT}/ "${bdir}/dynamic/"
   fi

   ctx[FINALENV]="${bdir}/final.env"
   ctx[LAYER_ORDER]="${bdir}/layer.order"
}



###############################################################################
# Stage 3: Filesystem build preparation
#   Create output directories
#   Resolve host paths
#   Build mission critical tools
#   Initialise bdebstrap environment - apt, proxy, cache, etc
#   Assemble compatible layers
###############################################################################
prepare_build_config()
{
   msg "\nPREPARE"

   set_kv() {
      local key="$1" val="$2"
      case $key in
         IGconf_device_hostname|\
         IGconf_image_name|\
         IGconf_image_outputdir|\
         IGconf_sys_workroot|\
         IGconf_target_dir|\
         IGconf_target_path|\
         IGconf_sys_workroot|\
         IGconf_sys_cachedir|\
         DEB_BUILD_GNU_TYPE)
            declare -g "$key"="$val"
            ;;
      esac
   }
   # Set these variables in the shell to simply further processing
   mapfile_kv "${ctx[FINALENV]}" set_kv

   # Create output dirs
   mkdir -p "$IGconf_target_dir" "$IGconf_sys_workroot" "$IGconf_sys_cachedir"
   [[ -n "${IGconf_image_outputdir:-}" ]] && mkdir -p "$IGconf_image_outputdir"

   # Build required host tools
   bootstrap_build_tools

   # Seed bdebstrap env with sane defaults
   _bdebstrap=()
   _bdebstrap+=( --force --env PATH="$PATH" )
   _bdebstrap+=( --name     "${IGconf_image_name:-rpi-image-gen}" )
   _bdebstrap+=( --hostname "${IGconf_device_hostname:-rpi-image-gen}" )
   _bdebstrap+=( --output   "${IGconf_target_dir:?not set}" )
   _bdebstrap+=( --target   "${IGconf_target_path:?not set}" )

   # Process all options from the configuration and selectively set apt/dpkg opts
   # or other dynamically driven settings.
   process_conf_opt() {
      local key=${1:-} value=${2:-}
      msg "-> $key : $value"
      case $key in
         IGconf_sys_apt_keydir)
            mkdir -p -- "$value" || die
            [[ -d /usr/share/keyrings ]] && rsync -a /usr/share/keyrings/ "$value"
            if [[ -n ${HOME:-} && -d ${HOME}/.local/share/keyrings ]]; then
               rsync -a "${HOME}/.local/share/keyrings/" "$value"
            fi
            rsync -a "${IGTOP}/keydir/" "$value"
            _bdebstrap+=( --aptopt "Dir::Etc::TrustedParts $value" ) ;;

         IGconf_sys_apt_cachedir)
            if [[ -n "$value" ]]; then
              local cache=$(realpath -e "$value") 2>/dev/null || die "$key specifies invalid dir ($value)"
              # @TODO passing --skip=cleanup/apt/cache needs bdebstrap 0.6.0+
              #_bdebstrap+=( --aptopt 'APT::Keep-Downloaded-Packages "true"' )
              #_bdebstrap+=( --aptopt 'Debug::pkgAcquire "true"' )
              #_bdebstrap+=( --aptopt 'Debug::Acquire::file "true"' )
              value="$cache"
            fi
            ;;

         IGconf_sys_apt_proxy_http)
            curl --silent --head --max-time 2 "$value" >/dev/null \
               || die "$key proxy unreachable ($value)"
               _bdebstrap+=( --aptopt "Acquire::http { Proxy \"$value\"; }" ) ;;

         IGconf_sys_apt_get_purge)
            [[ ${value,,} =~ ^y(es)?$ ]] \
               && _bdebstrap+=( --aptopt 'APT::Get::Purge true' ) ;;
      esac

      # pass through
      _bdebstrap+=( --env "$key=$value" )
   }
   msg "FINAL ENV"
   mapfile_kv "${ctx[FINALENV]}" process_conf_opt

   # Translate layer paths and load those that contain an mmdebstrap mapping
   msg "\nMMDEBSTRAP"
   local total=0 added=0 skipped=0
   local specs="${TMPDIR}/layer.resolved"

   : > $specs
   while IFS='=' read -r layer spec; do
      [[ -n $layer && -n $spec ]] || continue
      [[ $layer == \#* ]] && continue
      spec=${spec#\"}
      spec=${spec%\"}
      [[ -n $spec ]] || continue

      ((total++))
      local resolved=$(map_path "$spec") || die "Failed to resolve $spec"
      [[ -f $resolved ]] || die "Layer $layer ($resolved) not found"
      printf '%s="%s"\n' "$layer" "$resolved" >> "$specs"
   done < "${ctx[LAYER_ORDER]}"

   while IFS=: read -r layer yaml; do
      _bdebstrap+=( --config "$yaml" )
      msg "Loaded $layer"
      ((added++))
   done < <(python3 - "$specs" <<'PY'
import sys, yaml, pathlib
for raw in pathlib.Path(sys.argv[1]).read_text().splitlines():
    layer, path = raw.split('=', 1)
    path = path.strip().strip('"')
    data = yaml.safe_load(pathlib.Path(path).read_bytes())
    if isinstance(data, dict) and data.get("mmdebstrap"):
        print(f"{layer}:{path}")
PY
)
   local skipped=$((total - added))
   msg "Loaded ${added}/${total}, skipped $skipped"

   # Store variable name so we can get it by nameref. ctx is an associative
   # array and bash can't store another (indexed) array inside it.
   ctx[ENV_BDEBSTRAP]='_bdebstrap'

   msg "\nREADY"
}


###############################################################################
# Stage 4: Filesystem generation
#   run bdebstrap
#   SBOM
###############################################################################
generate_filesystem()
{
   [[ ${ctx[INTERACTIVE]}  == y ]] && { ask "Generate filesystem?" y || exit 0; }

   msg "\nFILESYSTEM"

   local -n _benv="${ctx[ENV_BDEBSTRAP]}" # via nameref

   rund "${ctx[SRCROOT]}" ns bdebstrap \
      "${_benv[@]}" \
      --setup-hook     'runner setup "$@"' \
      --extract-hook   'runner extract "$@"' \
      --essential-hook 'runner essential "$@"' \
      --customize-hook 'runner customize "$@"' \
      --cleanup-hook   'runner cleanup "$@"'

   runenv "${ctx[FINALENV]}" ns runner post-build

   [[ ${ctx[INTERACTIVE]} == y ]] && \
      { ask "Filesystem complete. Proceed to SBOM?" y || exit 0 ; }

   msg "\nSBOM"
   runenv "${ctx[FINALENV]}" ns runner sbom
}



###############################################################################
# Stage 5: Image generation
#   pre-image hooks
#   Invoke image provider
#   post-image hooks
###############################################################################
generate_images() {
   local provider=$(get_var IGconf_image_provider "${ctx[FINALENV]}")
   [[ -z "$provider" ]] && return 0

   [[ ${ctx[INTERACTIVE]} == y ]] && { ask "Generate image(s)?" y || exit 0 ; }

   local filesystem=$(get_var IGconf_target_path "${ctx[FINALENV]}") || die "no filesystem"
   local output_path=$(get_var IGconf_image_outputdir "${ctx[FINALENV]}") || die "no out path"

   msg "\nIMAGE"

   runenv "${ctx[FINALENV]}" ns runner pre-image

   if [[ "$provider" == genimage && -d "$filesystem" ]] ; then
      mkdir -p "${TMPDIR}/genimage"
      local cfg
      for cfg in "${output_path}"/genimage*.cfg; do
         [[ -f $cfg ]] || continue
         runenv "${ctx[FINALENV]}" ns env genimage \
            --rootpath   "$filesystem" \
            --tmppath    "${TMPDIR}/genimage" \
            --inputpath  "$output_path" \
            --outputpath "$output_path" \
            --loglevel=1 \
            --config     "$cfg"  \
            | pv -t -F 'Generating image...%t' \
            || die "genimage error ($cfg)"
      done
   fi

   runenv "${ctx[FINALENV]}" ns runner post-image
}



###############################################################################
# Stage 6: Deploy
#   Install build assets for distribution
###############################################################################
deploy() {
   runenv "${ctx[FINALENV]}" ns runner finalize

   [[ ${ctx[INTERACTIVE]} == y ]] && { ask "Deploy assets?" y || exit 0 ; }

   msg "\nDEPLOY"
   runenv "${ctx[FINALENV]}" ns runner deploy
}



###############################################################################
# Clean
###############################################################################
clean_worktree() {
   msg "\nCLEAN"
   : "${ctx[FINALENV]?FINALENV is not set}"

   local key val
   for key in IGconf_target_path IGconf_image_outputdir IGconf_image_deploydir; do
      val=$(get_var "$key" "${ctx[FINALENV]}") || continue
      [[ -e $val ]] || continue
      ask "Remove $key [$val]?" y || continue
      if [[ $key == IGconf_target_path ]]; then
         run ns rm -rf -- "$val"
      else
         rm -rf -- "$val"
      fi
   done
}



main() {
   run_stage() {
      local fn=$1; shift
      printf '\n\033[1m==> %s\033[0m\n' "$fn"
      "$fn" "$@" || die "Stage '$fn' failed"
   }

   case $cmd in
      build)
         run_stage parameter_assembly
         run_stage collect_layers
         run_stage prepare_build_config
         [[ "${ctx[ONLY_IMAGE]}" == y ]] || run_stage generate_filesystem
         [[ "${ctx[ONLY_FS]}" == y ]] || run_stage generate_images
         run_stage deploy
         ;;

      clean)
         run_stage parameter_assembly
         run_stage collect_layers
         run_stage clean_worktree
         ;;
   esac
}


main "$@"
